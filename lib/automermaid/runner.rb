class Automermaid::Runner
  def self.run
    lines = Automermaid::Scanner.new("~/Projects/Tackle").scan
    valid = lines.map {|line| Automermaid::Scanline.new(line).process }.compact
    pp valid

    # external systems and external database can be referenced at any time from any location
    external_systems = valid.inject({}) {|hsh, v| Automermaid::ExternalSystem.append_from(hsh, v) }
    external_dbs = valid.inject({}) {|hsh, v| Automermaid::ExternalDB.append_from(hsh, v) }
    external_queues = valid.inject({}) {|hsh, v| Automermaid::ExternalQueue.append_from(hsh, v) }

    # now the hard part; each system has
    # an enterprise boundary
    # an optional system boundary
    # a system name
    curr_enterprise_boundary = nil
    curr_system_boundary = nil
    curr_boundary = nil
    relations = []
    unused = []

    valid.sort {|lhs, rhs| lhs.path <=> rhs.path }.each do |v|
      case v.element
      when 'enterprise boundary'
        curr = Automermaid::EnterpriseBoundary.new(v)
        curr_enterprise_boundary = curr
        curr_system_boundary = nil
        curr_boundary = nil
        unused << curr
      when 'system boundary'
        curr = Automermaid::SystemBoundary.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary = curr
        curr_boundary = nil
        unused << curr
      when 'boundary'
        curr = Automermaid::Boundary.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary = curr
        unused << curr
      when 'system'
        curr = Automermaid::System.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary.append(curr) if curr_boundary
        unused << curr
      when 'system db'
        curr = Automermaid::SystemDB.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary.append(curr) if curr_boundary
        unused << curr
      when 'system queue'
        curr = Automermaid::SystemQueue.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary.append(curr) if curr_boundary
        unused << curr
      when "rel"
        curr = Automermaid::Relation.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary.append(curr) if curr_boundary
        unused << curr
      when "birel"
        curr = Automermaid::Relation.new(v)
        curr_enterprise_boundary.append(curr) if curr_enterprise_boundary
        curr_system_boundary.append(curr) if curr_system_boundary
        curr_boundary.append(curr) if curr_boundary
        unused << curr
      end
    end

    # In order attempt to build the diagram
    arr = []
    arr << "C4Context"
    arr << "title Autogenerated System Context Diagram"

    # These have ids that do not change by context
    external_systems.values.each {|es| arr << es.render }
    external_dbs.values.each {|ed| arr << ed.render }
    external_queues.values.each {|eq| arr << eq.render }

    # These are rendered and, once rendered, are assumed to not be rendered again
    used_ids = Set.new
    unused.each do |u|
      arr << u.render(used: used_ids) unless used_ids.member?(u.id)
    end

    File.write("graph.mmd", arr.join("\n"))
  end
end
